Considerations regarding this project:

Web Application Architecture Components

Typically, a web application architecture diagram comprises three core components:

1) Web Browser: The browser, client-side, or front-end component is the key component that interacts with the user, receives the input, and manages the presentation logic while controlling user interactions with the application. User inputs are validated as well if required.

2) !!!!Web Server: The web server, also known as the backend or server-side component, handles the business logic and processes the user requests by routing the requests to the right component and managing the entire application operations. It can run and oversee requests from a wide variety of clients.

3) Database Server: The database server provides the required data for the application. It handles data-related tasks. In a multi-tiered architecture, database servers can manage business logic with the help of stored procedures.

https://images.clickittech.com/2020/wp-content/uploads/2022/03/10202347/Diagram-54-scaled.jpg

https://images.clickittech.com/2020/wp-content/uploads/2022/03/10202353/Diagram-55-scaled.jpg

What is a web server? Simply put, a web server runs one or more websites or web apps. The web server uses HyperText Transfer Protocol (HTTP) and other protocols to view user requests via a browser. It processes them by applying business logic and delivering the requested content to the end-user.

NGINX is another popular web server called ‘Engine X.’ Developed by Igor Sysoev in 2004, NGINX quickly became popular. It operates on an event-driven model wherein thousands of requests are processed within a single thread, delivering more with minimal resources. It uses PHP to serve static resources and serves static content 2.5 times faster than Apache. Dynamic content is served via external processes. Regarding interpreting requests, Apache passes the file system location while NGINX passes the URI. This feature extends the NGINX capability as a load balancer, HTTP Cache, and proxy server.

Watch this Video: (and only ctrl+c and ctrl+v without the < and >)

CLI stands for Command line interface btw... that's your terminal.

Step 1.
If you are using Chrome as default browser
-> run: <open -a Google\ Chrome "https://www.youtube.com/watch?v=dQw4w9WgXcQ"> in CLI as an introduction!

For Firefox run this command:
-> run: <open -a /Applications/Firefox.app -g "https://www.youtube.com/watch?v=dQw4w9WgXcQ"> in CLI as an introduction!

Step 2. Profit??? (maybe write me a message as thanks :D)

Also if you want to compare behaviour and files to nginx install it using <brew install nginx>!
Also if you wanto to compare behvaiour and files to telnet install is using <brew install telnet>!
If you want to find file examples like mime.types or a nginx.conf default go to <User/{YourUserName}/.brew/etc/nginx>
-> Useful to see how it handles redirects to error pages for example and also alot of other stuff!!!!
-------------------------------------------------------------------------------------------------------------------------

Starting on CPP FILES:

First off: Decide which poll equivalent to use!.
Since we are coding on MacOS I would prefer we go with Kqueue since it is the most efficient on a BSD system.
(Scalability and performance)

Second: Info necessary to be able to understand what we do:
1. Crash Course on Containers, explicitly vectors and unordered maps.
2. Crash Course on memory pointer types to make memory management easier(weak, shared, unique pointers)
3. Crash Course on new keywords like noexcept, auto, override, nullptr, enum class, constexpr, explicit
4. Crash Course on regex library, chrono time library, also maybe multithreading library like <thread> or <future>?
5. Basic structure of webservers including:

-> config, fds, connections(accept, close, states(alive, timeout handling etc..)),
	kqueue, sockets(listen), port handling, event handlers, server_blocks, mime_types, file uploads, error handling

-> Request formatting including parsing of: method, http headers, body in ABNF (Augmented Backus-Naur Form: basically request syntax), clientside-GET, clientside-POST, clientside-DELETE

-> Response formatting: status, header, body, serverside-GET, serverside-POST, serverside-DELETE

-> how to set non-blocking and checks for errors as well as requesting info on file read-writes, and file exist checking

-> Macroes like: FD_SET, FD_CLR, FD_ISSET, FD_ZERO

-> Maybe also load balancing because of this requirement: Stress tests your server. It must stay available at all cost!
	-> is going to be difficult, we would need to start multiple webservers and link them automatically based on demand.
	-> probably better to just limit allowed connections to the server at one time!

-> CGI: Common Gateway Interface handling.

Additional Considerations:
-> Network Protocols like TCP and UDP
-> TLS
-> firewall
-> protection against different network attack types including but not limited to: DDoS, XSS injections, CSRF attacks.

Bonus:

-> Cookies + Session Management

-> multiple CGI
---------------------------------------------------------------------------------------------------------------------

Watch this Video as a introduction to NGINX:
<open -a /Applications/Firefox.app -g https://www.youtube.com/watch?v=9t9Mp0BGnyI> !!!
(For real)

Explanation of WebServer POST Request handling with WebServer already running:

WebServer:
The Webserver is already running, listening on configured ports.
When a new connection comes in, it accepts the connection and creates a new Connection object.

Event loop:
The new Connection's file descriptor is added to the event loop.
The event loop is constantly running, using poll() to check for activity on all file descriptors.

Connection:
When data is available to read, the event loop calls the Connection's read() method.
The Connection reads the incoming data into its buffer.

Request:
As data is read, the Connection passes it to an Request object for parsing.
The Request object identifies this as a POST request and extracts relevant information like headers and the request body.

Connection (processing):
Once the full request is received, the Connection determines how to handle it based on the server configuration.
For a POST request, it might involve saving an uploaded file or passing data to a CGI script.

CGI Handler (if applicable):
If the POST request is meant for a CGI script, the CGIHandler is invoked.
The CGIHandler executes the appropriate script, passing along the POST data.
The script's output is captured by the CGIHandler and returned.

Response: (Look up ABNF for proper formatting)
The Connection creates an Response object.
It sets the appropriate status code (e.g., 200 OK if successful).
It adds necessary headers (e.g., Content-Type, Content-Length).
It sets the body of the response (either a success message or the CGI script output).

Connection (sending):
The Connection converts the Response to a string.
It begins sending this data back to the client.

Event loop:
If the response can't be fully sent immediately, the event loop will notify when the socket is ready for more writing.
The Connection's write() method will be called to continue sending data.

Connection (cleanup):
Once the full response is sent, the Connection might close if it's not a keep-alive connection.
Otherwise, it resets its state and prepares for the next request.

WebServer:
If the connection is closed, the Webserver removes it from the event loop.

Throughout this process:

The event loop ensures that all operations are non-blocking.
Error handling occurs at each step (e.g., if the POST data is too large or if a CGI script fails).
Timeouts are managed to prevent connections from hanging indefinitely.
---------------------------------------------------------------------------------------------------------------------
Explanation of WebServer GET Request handling with WebServer already running:

WebServer:
The WebServer is already running, listening on configured ports.
When a new connection comes in, it accepts the connection and creates a new Connection object.

EventLoop:
The new Connection's file descriptor is added to the EventLoop.
The EventLoop is constantly running, using poll() to check for activity on all file descriptors.

Connection:
When data is available to read, the EventLoop calls the Connection's handleRead() method.
The Connection reads the incoming data into its buffer.

HttpRequest:
As data is read, the Connection passes it to an HttpRequest object for parsing.
The HttpRequest object identifies this as a GET request and extracts relevant information like the requested path and query parameters.

Connection (processing):
Once the full request is received, the Connection determines how to handle it based on the server configuration.
For a GET request, it typically involves retrieving a file from the server's filesystem.

File Retrieval:
The Connection checks if the requested file exists and is accessible.
If the file exists, it opens the file and prepares to send its contents.
If it's a directory and directory listing is enabled, it generates a directory listing.
If the file doesn't exist, it prepares to send a 404 Not Found response.

CGIHandler (if applicable):
If the GET request is for a CGI script (e.g., a .php file), the CGIHandler is invoked.
The CGIHandler executes the appropriate script, passing along any query parameters.
The script's output is captured by the CGIHandler and returned.

HttpResponse:
The Connection creates an HttpResponse object.
It sets the appropriate status code (e.g., 200 OK if the file was found, 404 if not).
It adds necessary headers (e.g., Content-Type based on the file type, Content-Length).
It sets the body of the response (either the file contents, directory listing, or CGI output).

Connection (sending):
The Connection converts the HttpResponse to a string.
It begins sending this data back to the client.

EventLoop:
If the response can't be fully sent immediately, the EventLoop will notify when the socket is ready for more writing.
The Connection's handleWrite() method will be called to continue sending data.

Connection (cleanup):
Once the full response is sent, the Connection might close if it's not a keep-alive connection.
Otherwise, it resets its state and prepares for the next request.

WebServer:
If the connection is closed, the WebServer removes it from the EventLoop.